可以！你要“用正则找出/排除 **未转义** 的 LaTeX 特殊字符”（在数学模式里不应直接裸用的那批：`# $ % & _ ^ { }`，以及你若想一起抓也可含 `\`），核心是**判断该字符前是否有奇数个反斜杠**。奇数=已转义，偶数=未转义。

下面给出几种常用引擎的稳妥写法：

---

#1 现代 JS / Python / PCRE（支持后行断言）
**匹配所有“未转义的特殊字符”**（会把前面成对的反斜杠一起匹配上）：

```
(?<!\\)(?:\\\\)*([#\$%&_\^\{\}])
```

* 解释：`(?<!\\)` 确保前一位不是 `\`；`(?:\\\\)*` 吃掉“偶数个反斜杠”；随后捕获真正的问题字符到分组1。
* 想把 `\` 本身也列为不允许：把类改为 `([\\#\$%&_\^\{\}])`。

**只高亮（捕获）问题字符，不连带前面的成对反斜杠（PCRE可用 \K）**：

```
(?<!\\)(?:\\\\)*\K([#\$%&_\^\{\}])
```

---

#2 旧版 JS（不支持后行断言）的等效写法
**匹配所有“未转义的特殊字符”**（用“起始或非反斜杠”+“偶数反斜杠”来替代后行）：

```
(^|[^\\])(\\\\)*([#\$%&_\^\{\}])
```

* 分组3就是问题字符；分组1+2是上下文。
* 做替换时保留上下文，再在分组3前加一个反斜杠即可：`$1$2\\$3`

---

#3 校验思路（验证字符串是否“无违规字符”）
通常更简单：**用上面的“匹配式”去 `search` 一下**。

* 找到 ⇒ 含未转义的禁用字符（无效）。
* 找不到 ⇒ 安全。

（可以写成负向前瞻版全行校验，但可读性差，不推荐。）

---

#4 一键自动修复：把未转义字符批量转义

* **Python 示例**

```python
import re
pat = re.compile(r'(?<!\\)(?:\\\\)*([#\$%&_\^\{\}])')
def escape_latex_specials(s: str) -> str:
    return pat.sub(lambda m: m.group(0)[:-1] + '\\' + m.group(1), s)
```

* **旧版 JS 示例（无后行断言）**

```js
const pat = /(^|[^\\])(\\\\)*([#\$%&_\^\{\}])/g;
function escapeLatexSpecials(s) {
  return s.replace(pat, (_, g1, g2 = "", g3) => `${g1}${g2}\\${g3}`);
}
```

---

#5 可选细化（如果你在“数学模式”里**允许** `_`/`^` 作为上下/下标）
上面是“严格禁止裸用”的黑名单策略。如果你想**允许**合法的上/下标，而只抓**明显不合法**的 `_`/`^`，可以加一点上下文判断（例：不跟 `{` 或单字母/命令时才算违规）。示意（简化）：

```
未转义且   _  后面不是  \{ 也不是  [A-Za-z0-9]
(?<!\\)(?:\\\\)*_(?!\{|\p{L}|\d)

未转义且   ^  后面不是  \{ 也不是  [A-Za-z0-9]
(?<!\\)(?:\\\\)*\^(?!\{|\p{L}|\d)
```

> 说明：`\p{L}` 需 Unicode 正则支持；实际工程里可根据你的“合法 token”规则再精修。

---

## 小结

* **黑名单**字符类：`[#\$%&_\^\{\}]`（需要时加 `\\`）。
* **关键判定**：该字符前是否是**偶数个**反斜杠（= 未转义）。
* 有后行断言就用：`(?<!\\)(?:\\\\)*...`；没有就用“`(^|[^\\])(\\\\)*...`”的替代写法。

如果你告诉我你要用的具体语言/引擎（Python `re`、Rust `regex`、Java、Go、PCRE、.NET、浏览器 JS 等）和你的允许/禁止细则，我可以把正则和替换代码调到最严谨版本。
